!!!!!
. /lib/init/fstab: revert entry0 to original!!!
. Either
  (1) fix uramdisk init script
  (2) omit uramdisk
  (3) figure out why mountall.conf hack (mount ro) doesn't work.
--------------------------------------------------------------------------------
fsckfix-ro-mountall log:
. mark_mounted() doesn't report '/' as mounted: good.
  So mountall.conf hack works so far: ie rootfs is mounted but needs_remount().
. "try_mount: / waiting for device"?? mark it nobootwait?
--------------------------------------------------------------------------------
mounts: list of mounts we need to process, parsed from /etc/fstab + built-ins +
	prev-mounted filesystems
--------------------------------------------------------------------------------
/lib/init/fstab: filesystems always mounted @ boot; /etc/fstabs overrides this.
 every entry is filesystem=none except
  /dev/root / rootfs defaults 0 1 # ????
--------------------------------------------------------------------------------
main
 parse_filesystems
 parse_fstab(/lib/init/fstab)
  update_mount
 parse_fstab(/etc/fstab)
  update_mount
 parse_mount
  parse_mountinfo_file(/proc/self/mountinfo) # who needs /etc/mtab?
   update_mount
 mount_policy
 mark_mounted
  if mnt.mounted && !needs_remount(): mounted()
 try_mounts
--------------------------------------------------------------------------------
has_option(mnt, option, current)
 opts = current ? mnt.mount_opts : mnt.opts
 return TRUE iff any of given option list found in opts
 # mnt.mounted = <from /proc/self/mountinfo, ie current>
--------------------------------------------------------------------------------
needs_remount(mnt)
 # If currently-mounted ro but fstab says rw.
 # Ie kernel or uramdisk.init mounted rootfs ro, per bootparam(7).
 return mnt.mounted && has_option(mnt, "ro", TRUE) !has_option(mnt, "ro", FALSE)
--------------------------------------------------------------------------------
update_mount(mnt, device, check, type, opts)
 # callers set check=(fstab_entry.passno != 0)
 if device: mnt.device = device
 if check >=0: mnt.check = check # ie leave as-is if check == -1
 if type: mnt.type=type
 if opts: mnt.opts = opts
 D"update_mount: $MOUNT_NAME $mountpoint $device $type $opts $check
--------------------------------------------------------------------------------
new_mount(mnt, device, check, type, opts)
 mnt.mountpoint = mountpoint
 list_add(mounts, &mnt.entry)
 update_mount()
--------------------------------------------------------------------------------
parse_mountinfo_file(reparsed)
 # we parse /proc/self/mountinfo, ie currently-active mounts.
 # We put parsed opts into mnt.mount_opts.
 # Unless we've never seen this mountpoint before, we leave mnt.opts alone.
 if reparsed: rewind(mountinfo)
 D"parse_mountinfo_file: updating mounts"
 while fgets(mountinfo)
   id parent_id major:minor root mountpoint mount_opts type device super_opts
   if (mnt = find_mount(mountpoint)):
    # /lib/init/fstab entry0: creates mnt.mountpoint=/ with NULL device,type
    if type==(rootfs|swap): type=NULL 		# /lib/init/fstab entry0
    if device==(/dev/root|none): device=NULL	# /lib/init/fstab entry0
    update_mount(mnt, device, -1, type, NULL) 	# leave mnt.opts alone
   else
    new_mount(mnt, device, -1, type, opts)
   mnt.mount_opts = opts
--------------------------------------------------------------------------------
parse_fstab(filename)
 D"parse_fstab: updating from $filename"
 while getmntent(setmntent(filename, "r"))
   if find_mount()
    update_mount()
   else
    new_mount()
--------------------------------------------------------------------------------
spawn(mnt, args, wait, handler)
 parent:
  if wait: 
    waitid()
    spawn_child_handler(proc)
    return 0
 else
   nih_child_add_watch(spawn_child_handler, proc)
   return pid
--------------------------------------------------------------------------------
spawn_child_handler(proc, status)
  "mount $MOUNT_NAME [$pid] exited normally"
  if proc.handler: handler(mnt, pid, status) # ie call run_mount_finished()
--------------------------------------------------------------------------------
mounted(mnt)
 mnt.mounted=TRUE
 mnt.error = ERROR_NONE
 plymouth_update(FALSE)
 emit_event("mounted", mnt)
 unref(mnt.mount_opts, mounts)
 fsck_update()
--------------------------------------------------------------------------------
run_mount(mnt, fake)
 if fake: mtab %s
 else if (mnt.mount_pid > 0) "%s: already mounting"; return
 else if (mnt.error > ERROR_BORED) "%s still has uncleared errors"; return 
 else if mnt.mounted
   if !needs_remount: "%s already mounted"; return
 else if mnt.nodev && type==none: mnt.mounted=TRUE; return
 else "mounting %s"

 opts = cut_options(): remove mountall-specific opts from mnt.opts.
 opts += remount if mnt.mounted
 build args: mount -t $type -o $opts $device
 	args += -f[if fake]
        args += $mountpoint
 if fake: spawn(wait=TRUE, handler=NULL)
 else if !mnt.remote: spawn(wait=TRUE, handler=run_mount_finished)
 else spawn(wait=FALSE, handler=run_mount_finished)
--------------------------------------------------------------------------------
emit_event(name, mnt)
 if mnt:
  DEVICE=$mnt.device
  MOUNTPOINT=$mnt.mountpoint
  TYPE=$mnt.type
  OPTIONS=$mnt.opts
  upstart_emit_event(upstart, name, env, TRUE)
 else
  upstart_emit_event(upstart, name, NULL, FALSE)
--------------------------------------------------------------------------------
try_mount(mnt, force) # force=FALSE always AFAIK
foreach mnt.deps
 if dep not mounted: D"$MOUNT_NAME waiting for $dep.mountpoint; return
# "if there's an underlying dev that udev is going to deal with,
# we wait for the udev watcher to mark it ready."
if !mnt.ready & !mnt.nodev & !is_remote(mnt) & mnt.device == /dev/xxx:
 D"$MOUNT_NAME waiting for device"
 return
if !mnt.ready && !is_remote(mnt):
 run_fsck()
else
 emit_event("mounting", mnt)
 run_mount()
--------------------------------------------------------------------------------
try_mounts()  # called from main(); also is our main_loop() callback
   once this finds all mounts done, calls
	dbus_server_disconnect(control_server)
	main_loop_exit(OK)
   for unmounted (or needs remount) mounts: try_mount()
       foreach mnt.deps
  	  if dep not mounted, wait (ie skip this mount)
   	  if (!mnt.ready && mnt.device == /dev/xxx) wait for udev
      	  if (!mnt.ready && !remote) run_fsck()
          else run_mount()
--------------------------------------------------------------------------------
run_mount_finished(mnt, pid, status)
 mnt.error = ERROR_NONE
 if !mnt.mounted: <parse mountinfo to see what mount did>
 if !mnt.mounted: mounted(mnt)
--------------------------------------------------------------------------------
run_fsck(mnt)
 if mnt.ready
  D"$MOUNT_NAME: already ready"
  try_mount(mnt, FALSE)
  return
 else if !mnt.check & (!force_fsck || mnt.mountpoint!=/)
  D"$MOUNT_NAME: no check required"
  mnt.ready = TRUE
  try_mount(mnt, FALSE)
  return
--------------------------------------------------------------------------------
run_fsck_finished()
man fsck: exit code is the sum of following conditions:
  1 - fs errors corrected
  2 - sys must be rebooted
  4 - fs errors left uncorrected
  8 - operational error
  16 - usage/syntax error
  32 - fsck cancelled by user request
  128 - shlib error
if (status & 2) exit(EXIT_REBOOT)
--------------------------------------------------------------------------------
plymouth_answer(): callback registered for ply_boot_client_ask_daemon_to_watch_for_keystroke():
  plymouth_update(only_clear msg = (keys[0]=={M} ? TRUE: {F,I,S,C} ? FALSE)
    display highest-priority mnt.error for any fsck in progress:
    %s=MOUNT_NAME
    	The disk drive for %s is not ready yet or not present.
	 Continue to wait, or Press S to skip mounting or M for manual recovery.
	Errors were found while checking the disk drive for %s.
	 Press F to attempt to fix the errors, I to ignore, S to skip mounting, or M for manual recovery
	Serious errors were found while checking the disk drive for %s.
	 Press I to ignore, S to skip mounting, or M for manual recovery
	An error occurred while mounting %s.
	 Press S to skip mounting or M for manual recovery"
	Checking disk drives for errors. This may take several minutes.
	 Press C to cancel all checks in progress.

================================================================================
Per http://web.dodds.net/~vorlon/wiki/blog/Plymouth_is_not_a_bootsplash/
mountall handles filesystem mounting (and fsck'ing) in parallel.
Plymouth is a boot-time I/O multiplexer.
Plymouth - without splash boot arg - provides text-only console interface.

Are we running with plymouth? Your plymouth.conf chg to --attach_session (sp?)
made a big diff (plymouth_connect() now succeeds "Connected to Plymouth"): why?
Googled 'zynq plymouth' and found discussion at forums.xilinx.com (incl doreen).
Grepped kernel sources (but not official version) for early_param(console).
Only found early_param(early_con), in drivers/tty/serial/8250/8250_early.c.
These 2 params are handled early in main.c.
------------------
/etc/init/mountall.conf:
	Kernel mounts rootfs before running init?
	Then mountall has _nothing_ to do except mount /mnt/boot, emit sigs.
------------------
So what does mountall do?
 mounts filesystems in dependency order, but in parallel if possible.
 emits 'filesystems' etc events to Upstart via Dbus 
 runs fsck: passes errors to user and asks (via Plymouth) for what to do
 your fstab assigns /mnt/boot a passno!=0, right? That forces fsck!
      see fs_passno description on fstab(5) manpage.
      note (line 2327 mountall.c) that rootfs is NOT fsck'd even if force_fsck.
      Is there an fsck.vfat in PATH? (See missing_fsck() line 2332.)
      line 2344: if mnt.mounted don't fsck it UNLESS it's "ro".
		Perhaps we fsck /mnt/boot before _and_ after mounting it?
 parses fsck output to update plymouth progress bar:
    wikipedia: Plymouth "also handles user interaction during boot"
  "Disconnected from Plymouth": perhaps we try to connect to plymouth during
    fsck (plymouth_progress()) and this must immediately invoke
     plymouth_disconnected() which prints the "Disconnected from..." msg.
     Might try booting laptop from SD card just to see Plymouth fsck progress.
     See google/bookmark under ubuntu-upstart, or google
 	 "ubuntu boot from sd card".
------------------
mount(8) manpage
 mount options
  defaults={rw, suid, dev, exec, auto, nouser, async}
------------------
fstab(5) manpage [in precise]:
   mountall(8) recognizes addtl options: 
	bootwait, nobootwait, showthrough, optional.
main
0) nih_option_parser(): try verbose, debug, & help options.

1)
  connect to upstart (/com/Ubuntu/Upstart) via dbus proxy 
   addr of private D-Bus srvr inside Upstart "unix:abstract=/com/ubuntu/upstart"
   our control server address: "unix:abstract=/com/ubuntu/mountall"
   obj path used by manager object (root used for all other objs):
		/com/ubuntu/Mountall/Server
2) connect to udev via monitor,
     add read watch routine - udev_monitor_watcher() - for monitor fd.
3) plymouth event loop
     add read watch routine - ply_event_loop_process_pending().
     plymouth_connect() ??
x) init 'mounts' list
4) Parse /proc/filesystems (??)
   build filesystems[] = {name, nodev} for each filesystem.
5) init mount table:
    add a new Mount entry to mounts list, 
       unless it's already there in which case update it
     NB: mnt.check = (passno != 0)
   Do this for 
	/lib/init/fstab (builtin fstab)
        /etc/fstab
 	/proc/mounts (aka /proc/self/mountinfo)
   libc <mntent.h>: access etc/fstab & /etc/mtab.
	struct mntent {
 		char *fsname (device), *dir (mountpoint), *type, *opts;
		int freq (dump freq in days), passno (parallel fsck);
	}
6) mount_policy()
   build already_mounted list; ignore mounts that would hide already-mnted.
   build mnt.deps: parents of each mount (child mount will wait for parent)
x) open_control_server()
    DBusServer = dbus_server( "unix:abstract=/com/ubuntu/mountall", ...)
    register 'DBusInterface control_interfaces[]' on /com/ubuntu/Mountall/Server
    ??
7) try_mounts() (our main_loop() callback)
   once this finds all mounts done, calls
	dbus_server_disconnect(control_server)
	main_loop_exit(OK)
   for unmounted (or needs remount) mounts: try_mount()
       foreach mnt.deps
  	  if dep not mounted, wait (ie skip this mount)
   	  if (!mnt.ready && mnt.device == /dev/xxx) wait for udev
      	  if (!mnt.ready && !remote) run_fsck()
          else run_mount()
8) run_mount()
    nih_info("mounting %s")
     spawn({mount -t <typ> -o <opts> device mountpoint}, run_mount_finished)
9) run_mount_finished()
    mnt.mounted = TRUE; -> main_loop_interrupt()
10) trigger_events() calls upstart_emit_event(upstart) ie via D-Bus:
	remote-filesystems
	virtual-filesystems
	local-filesystems
	filesystems = "aggregate event for all filesystems" = {virt, loc, rem}
11) plymouth_progress(): only if plymouth
