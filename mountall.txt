--------------------------------------------------------------------------------
mounts: list of mounts we need to process, parsed from /etc/fstab + built-ins +
	prev-mounted filesystems
--------------------------------------------------------------------------------
/lib/init/fstab: filesystems always mounted @ boot; /etc/fstabs overrides this.
 every entry is filesystem=none except
  /dev/root / rootfs defaults 0 1
--------------------------------------------------------------------------------
update_mount(mnt, device, check, type, opts)
 if device: mnt.device = device
 if check >=0: mnt.check = check
 if type: mnt.type=type
 if opts: mnt.opts = opts
 D"update_mount: $MOUNT_NAME $mountpoint $device $type $opts $check
--------------------------------------------------------------------------------
parse_mountinfo_file(reparsed)
 if reparsed: rewind(mountinfo)
 D"updating mounts"
 while fgets(mountinfo)
   id parent_id major:minor root mountpoint mount_opts type device super_opts
   mnt = find_mount(mountpoint)
   if type==rootfs OR device=/dev/root: type=NULL #/lib/init/fstab entry0
   update_mount(mnt, device, -1, type, NULL)
--------------------------------------------------------------------------------
spawn(mnt, args, wait, handler)
 parent:
  if wait: 
    waitid()
    spawn_child_handler(proc)
    return 0
 else
   nih_child_add_watch(spawn_child_handler, proc)
   return pid
--------------------------------------------------------------------------------
spawn_child_handler(proc, status)
  "mount $MOUNT_NAME [$pid] exited normally"
  if proc->handler: handler(mnt, pid, status) # ie call run_mount_finished()
--------------------------------------------------------------------------------
mounted(mnt)
 mnt.mounted=TRUE
 mnt.error = ERROR_NONE
 plymouth_update(FALSE)
 emit_event("mounted", mnt)
 unref(mnt.mount_opts, mounts)
 fsck_update()
--------------------------------------------------------------------------------
run_mount(mnt, fake)
 if fake: mtab %s
 else if (mnt.mount_pid > 0) "%s: already mounting"; return
 else if (mnt.error > ERROR_BORED) "%s still has uncleared errors"; return 
 else if mnt.mounted
   if !needs_remount: "%s already mounted"; return
 else if mnt.nodev && type==none: mnt.mounted=TRUE; return
 else "mounting %s"

 opts = cut_options(): remove mountall-specific opts from mnt.opts.
 opts += remount if mnt.mounted
 build args: mount -t $type -o $opts $device
 	args += -f[if fake]
        args += $mountpoint
 if fake: spawn(wait=TRUE, handler=NULL)
 else if !mnt.remote: spawn(wait=TRUE, handler=run_mount_finished)
 else spawn(wait=FALSE, handler=run_mount_finished)
--------------------------------------------------------------------------------
run_mount_finished(mnt, pid, status)
 mnt.error = ERROR_NONE
 if !mnt.mounted: <parse mountinfo to see what mount did>
 if !mnt.mounted: mounted(mnt)
--------------------------------------------------------------------------------
run_fsck_finished()
man fsck: exit code is the sum of following conditions:
  1 - fs errors corrected
  2 - sys must be rebooted
  4 - fs errors left uncorrected
  8 - operational error
  16 - usage/syntax error
  32 - fsck cancelled by user request
  128 - shlib error
if (status & 2) exit(EXIT_REBOOT)
--------------------------------------------------------------------------------
plymouth_answer(): callback registered for ply_boot_client_ask_daemon_to_watch_for_keystroke():
  plymouth_update(only_clear msg = (keys[0]=={M} ? TRUE: {F,I,S,C} ? FALSE)
    display highest-priority mnt->error for any fsck in progress:
    %s=MOUNT_NAME
    	The disk drive for %s is not ready yet or not present.
	 Continue to wait, or Press S to skip mounting or M for manual recovery.
	Errors were found while checking the disk drive for %s.
	 Press F to attempt to fix the errors, I to ignore, S to skip mounting, or M for manual recovery
	Serious errors were found while checking the disk drive for %s.
	 Press I to ignore, S to skip mounting, or M for manual recovery
	An error occurred while mounting %s.
	 Press S to skip mounting or M for manual recovery"
	Checking disk drives for errors. This may take several minutes.
	 Press C to cancel all checks in progress.

================================================================================
Per http://web.dodds.net/~vorlon/wiki/blog/Plymouth_is_not_a_bootsplash/
mountall handles filesystem mounting (and fsck'ing) in parallel.
Plymouth is a boot-time I/O multiplexer.
Plymouth - without splash boot arg - provides text-only console interface.

Are we running with plymouth? Your plymouth.conf chg to --attach_session (sp?)
made a big diff (plymouth_connect() now succeeds "Connected to Plymouth"): why?
Googled 'zynq plymouth' and found discussion at forums.xilinx.com (incl doreen).
Grepped kernel sources (but not official version) for early_param(console).
Only found early_param(early_con), in drivers/tty/serial/8250/8250_early.c.
These 2 params are handled early in main.c.
------------------
/etc/init/mountall.conf:
	Kernel mounts rootfs before running init?
	Then mountall has _nothing_ to do except mount /mnt/boot, emit sigs.
------------------
So what does mountall do?
 mounts filesystems in dependency order, but in parallel if possible.
 emits 'filesystems' etc events to Upstart via Dbus 
 runs fsck: passes errors to user and asks (via Plymouth) for what to do
 your fstab assigns /mnt/boot a passno!=0, right? That forces fsck!
      see fs_passno description on fstab(5) manpage.
      note (line 2327 mountall.c) that rootfs is NOT fsck'd even if force_fsck.
      Is there an fsck.vfat in PATH? (See missing_fsck() line 2332.)
      line 2344: if mnt->mounted don't fsck it UNLESS it's "ro".
		Perhaps we fsck /mnt/boot before _and_ after mounting it?
 parses fsck output to update plymouth progress bar:
    wikipedia: Plymouth "also handles user interaction during boot"
  "Disconnected from Plymouth": perhaps we try to connect to plymouth during
    fsck (plymouth_progress()) and this must immediately invoke
     plymouth_disconnected() which prints the "Disconnected from..." msg.
     Might try booting laptop from SD card just to see Plymouth fsck progress.
     See google/bookmark under ubuntu-upstart, or google
 	 "ubuntu boot from sd card".
------------------
mount(8) manpage
 mount options
  defaults={rw, suid, dev, exec, auto, nouser, async}
------------------
fstab(5) manpage [in precise]:
   mountall(8) recognizes addtl options: 
	bootwait, nobootwait, showthrough, optional.
main
0) nih_option_parser(): try verbose, debug, & help options.

1)
  connect to upstart (/com/Ubuntu/Upstart) via dbus proxy 
   addr of private D-Bus srvr inside Upstart "unix:abstract=/com/ubuntu/upstart"
   our control server address: "unix:abstract=/com/ubuntu/mountall"
   obj path used by manager object (root used for all other objs):
		/com/ubuntu/Mountall/Server
2) connect to udev via monitor,
     add read watch routine - udev_monitor_watcher() - for monitor fd.
3) plymouth event loop
     add read watch routine - ply_event_loop_process_pending().
     plymouth_connect() ??
x) init 'mounts' list
4) Parse /proc/filesystems (??)
   build filesystems[] = {name, nodev} for each filesystem.
5) init mount table:
    add a new Mount entry to mounts list, 
       unless it's already there in which case update it
     NB: mnt->check = (passno != 0)
   Do this for 
	/lib/init/fstab (builtin fstab)
        /etc/fstab
 	/proc/mounts (aka /proc/self/mountinfo)
   libc <mntent.h>: access etc/fstab & /etc/mtab.
	struct mntent {
 		char *fsname (device), *dir (mountpoint), *type, *opts;
		int freq (dump freq in days), passno (parallel fsck);
	}
6) mount_policy()
   build already_mounted list; ignore mounts that would hide already-mnted.
   build mnt->deps: parents of each mount (child mount will wait for parent)
x) open_control_server()
    DBusServer = dbus_server( "unix:abstract=/com/ubuntu/mountall", ...)
    register 'DBusInterface control_interfaces[]' on /com/ubuntu/Mountall/Server
    ??
7) try_mounts() (our main_loop() callback)
   once this finds all mounts done, calls
	dbus_server_disconnect(control_server)
	main_loop_exit(OK)
   for unmounted (or needs remount) mounts: try_mount()
       foreach mnt->deps
  	  if dep not mounted, wait (ie skip this mount)
   	  if (!mnt->ready && mnt->device == /dev/xxx) wait for udev
      	  if (!mnt->ready && !remote) run_fsck()
          else run_mount()
8) run_mount()
    nih_info("mounting %s")
     spawn({mount -t <typ> -o <opts> device mountpoint}, run_mount_finished)
9) run_mount_finished()
    mnt->mounted = TRUE; -> main_loop_interrupt()
10) trigger_events() calls upstart_emit_event(upstart) ie via D-Bus:
	remote-filesystems
	virtual-filesystems
	local-filesystems
	filesystems = "aggregate event for all filesystems" = {virt, loc, rem}
11) plymouth_progress(): only if plymouth
